## Runtime

Wrapper для запуска бинарных файлов действий.

Получая от вышестоящего узла сообщение, Runtime регистрирует его номер, а также номер узла, от которого пришло сообщение. Полезные данные передаются действию в стандартный поток ввода. Длина полезных данных ответа может быть равна нулю, это означает, что входное сообщение было пропущено.

Сообщения, порождаемые действием, попадают в выходную очередь и записываются на диск. Идентификатор выходного сообщения генерируется в Runtime, при этом последовательность сгенерированных идентификаторов монотонно возрастает. Сообщения из выходной очереди по порядку идентификаторов рассылаются всем нижестоящим узлам, которые связаны с текущим.

Так как от нижестоящих узлов вышестоящим могут передаваться только подтверждения, а количество их типов было сокращено до одного, то этим сообщениям не требуется содержать какие-либо данные, кроме номера подтверждаемого сообщения. Поэтому подтверждение представляет собой 32-битное беззнаковое целое число.

После получения подтверждения Runtime усекает свою выходную очередь, а также формирует по записанным ранее идентификаторам вышестоящего узла и идентификаторам входных сообщений свои подтверждения и отправляет их вышестоящим узлам.

Runtime исполняет команды Machine Node. Всего таких команды две:
* команда `ping`, которая возвращает информацию о состоянии и действия;
* команда `change_out`, которая предназначена для замены одного из выходных узлов, а также передаче ему всех неподтвержденных сообщений.

Команды передаются по следующему протоколу. Сначала Machine Node отправляет 8-битное беззнаковое целое число, идентифицирующее команду. Для команды `ping` это число равно 1, а для команды `change_out` — 2. После этого следует тело команды: для команды `ping` оно пустое, а для команды `change_out` содержит старый IP-адрес и порт и новый IP-адрес и порт.

Ответ Runtime для Machine Node также начинается с 8-битного беззнакового целого числа, которое обозначает код ответа. Код ответа 0 означает успешное выполнение команды, код ответа 1 — ошибку при выполнении команды, а код ответа 2 возникает, если переданная команда неизвестна. После кода ответа следует тело ответа: для команды `change_out` оно пустое, для команды `ping` содержит информацию о состоянии. В ответ на команду `ping` возвращается 32-битное беззнаковое целое число, представляющее идентификатор самого старого сообщения, находящегося в выходной очереди.

### Действия

Действия создает пользователь, реализуя необходимую бизнес-логику. Для обмена данными действия используют [стандартные потоки](https://www.gnu.org/software/libc/manual/html_node/Standard-Streams.html):

* STDIN: используется для получения входящих сообщений.
* STDOUT: используется для записи исходящих сообщений.
* STDERR: используется для вывода ошибок, а также логирования.

По своей роли действия делятся на 3 группы:

* Источники данных: порождают поток данных, т.е. не имеют входных потоков. На практике это означает, что из STDIN ничего не читается. Если выходных потоков несколько, то данные копируются всем получателям одновременно.
* Обработчики данных: обрабатывают данные, при этом данные из нескольких входов сливаются в один в порядке их получения сервером. Используют и STDIN, и STDOUT. Правило копирования STDOUT аналогично источнику данных.
* Стоки: собирают данные, сливают несколько входных потоков в один аналогично обработчику.

### Гарантия доставки сообщений

GoStreaming обеспечивает доставку сообщений с гарантией *at-least-once*, что означает, что в случае отказа, некоторые сообщения могут дублироваться, но никогда не будут пропущены.
*Отсюда следует, что действия должны быть идемпотентными.*

### Создание действия

Действие создается с помощью библиотеки, специализированной для языка программирования. Библиотеки находятся в директории `lib`.

Рассмотрим написание действия на примере фильтра, который находится в `examples/simplepipe/filter`:

```go
var mod int
func init() {
    // Действия можно конфигурировать с помощью флагов и переменных окружения. В данном случае используем флаг --mod для задания делителя.
	flag.IntVar(&mod, "mod", 1, "passes messages that are multiples of mod")
}
func main() {
	flag.Parse()
	for {
        // Загружаем очередное сообщение из входного потока
		data, err := actionlib.ReadMessage()
		if err != nil {
            // Логирует ошибку и продолжает обработку уже нового сообщения.
			actionlib.WriteError(err)
            continue
		}
        // Получаем переданное число, в этом
        // месте может быть использован любой пользовательский протокол, например JSON.
		number := binary.BigEndian.Uint32(data)
		if int(number)%mod != 0 {
            // В случае, если число не кратно mod
            // то пропускаем его.
            // Вызов AckMessage() означает, что сообщение считано,
            // но вывода не последует.
			actionlib.AckMessage()
			continue
		}
        // В противном случае записываем исходное сообщение без изменений.
		if err := actionlib.WriteMessage(data); err != nil {
            // Логирует ошибку и продолжает обработку уже нового сообщения.
			actionlib.WriteError(err)
            continue
		}
	}
}
```

Как видно из примера, действия будут представлять из себя read/write loop, который заключает в себе логику обработки сообщения.

### Конфигурация действий

Действия можно конфигурировать с помощью аргументов командной строки, в т.ч. и флагов, а также с помощью переменных окружения. Это значения задаются при описании схемы.

